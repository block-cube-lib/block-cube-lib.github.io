<!DOCTYPE html>
<head>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148823095-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-148823095-1');
    window['ga-disable-UA-148823095-1'] = true;
  </script>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>blockの巣</title>
  <link rel="stylesheet" type="text/css" href="https://block-cube-lib.github.io/style.css">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
</head>

<body>
  <script src="https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.js" data-cfasync="false"></script>
  <header class="header">
    <div class="container">
      <a href="https:&#x2F;&#x2F;block-cube-lib.github.io&#x2F;">blockの巣</a>
      <nav>
        
        <a class="nav_content" href="https:&#x2F;&#x2F;block-cube-lib.github.io&#x2F;blog&#x2F;">Blog</a>
        
        <a class="nav_content" href="https:&#x2F;&#x2F;block-cube-lib.github.io&#x2F;tags&#x2F;">Tags</a>
        
        <a class="nav_content" href="https:&#x2F;&#x2F;block-cube-lib.github.io&#x2F;about&#x2F;">About</a>
        
        <a class="nav_content" href="https:&#x2F;&#x2F;block-cube-lib.github.io&#x2F;works&#x2F;">Works</a>
        
        <a class="nav_content" href="https:&#x2F;&#x2F;block-cube-lib.github.io&#x2F;privacy-policy&#x2F;">Privacy Policy</a>
        
      </nav>
    </div>
  </header>
  <section class="section">
    <div class="container">
      
<h1 class="title">
  Rustでコンパイル時レイトレーシング3
</h1>

  <span class = "date">2022&#x2F;02&#x2F;04 00:20</span>

<section class="tags">
  
  
  
  <span class = "tag">
    <a href="https://block-cube-lib.github.io/tags/compile-time-ray-tracing-in-rust/">Compile Time Ray Tracing in Rust</a> 
  </span>

  
  
  <span class = "tag">
    <a href="https://block-cube-lib.github.io/tags/ray-tracing/">Ray Tracing</a> 
  </span>

  
  
  <span class = "tag">
    <a href="https://block-cube-lib.github.io/tags/rust/">Rust</a> 
  </span>

  

</section>
<p><p>更新履歴<br />
2022-02-05T12:52:00+09:00: 背景色が間違っていたのを修正 </p>
<hr />
<p><a href="../compile-time-ray-tracing-in-rust-2">前回記事</a><br />
<a href="https://github.com/block-cube-lib/compile-time-ray-tracing-in-rust/tree/f742634a84aadda4ff24f28549645123831141de">リポジトリ</a></p>
<p>今回はようやくレイを飛ばすところまで行けました！<br />
といってもオブジェクトにヒットするとかはしておらずレイの向きによって色が変わっているだけなのでまだレイトレーシングっぽくないですね。</p>
<p>レンダリング結果<br />
<img src="/image/compile-time-ray-tracing-in-rust/image2.png" alt="レンダリング結果" /></p>
<h2 id="jin-hui-nobian-geng-dian">今回の変更点</h2>
<ul>
<li><code>Ray</code>型を追加(<code>ray.rs</code>)</li>
<li>新しい<code>feature</code>(<code>const_eval_limit</code>)を追加</li>
<li><code>main.rs</code>で<code>Ray</code>を使用する</li>
</ul>
<h3 id="ray-rs">ray.rs</h3>
<p>まず<code>Ray</code>型の内容からです。
レイの始点と方向を持つだけの<code>struct</code>です。特別注意が必要なことはないと思います。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use crate</span><span>::{Point3, Vec3};
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Clone, Copy, Debug)]
</span><span style="color:#b48ead;">pub struct </span><span>Ray {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">orig</span><span>: Point3,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">dir</span><span>: Vec3,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Ray {
</span><span>    </span><span style="color:#b48ead;">pub const fn </span><span style="color:#8fa1b3;">new</span><span>(</span><span style="color:#bf616a;">origin</span><span>: &amp;Point3, </span><span style="color:#bf616a;">direction</span><span>: &amp;Vec3) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        Ray {
</span><span>            orig: origin.</span><span style="color:#96b5b4;">clone</span><span>(),
</span><span>            dir: direction.</span><span style="color:#96b5b4;">clone</span><span>(),
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">pub const fn </span><span style="color:#8fa1b3;">origin</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; Point3 {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.orig
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">pub const fn </span><span style="color:#8fa1b3;">direction</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; Vec3 {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.dir
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">pub const fn </span><span style="color:#8fa1b3;">at</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">t</span><span>: </span><span style="color:#b48ead;">f64</span><span>) -&gt; Vec3 {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.orig + </span><span style="color:#bf616a;">self</span><span>.dir * t
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="lib-rs">lib.rs</h3>
<p><code>lib.rs</code>の内容は<code>ray</code> moduleの宣言などの他<code>const_eval_limit</code>という<code>feature</code>の宣言が増えています。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#bf616a;">feature</span><span>(const_trait_impl)]
</span><span>#![</span><span style="color:#bf616a;">feature</span><span>(const_fn_floating_point_arithmetic)]
</span><span>#![</span><span style="color:#bf616a;">feature</span><span>(const_mut_refs)]
</span><span>#![</span><span style="color:#bf616a;">feature</span><span>(const_eval_limit)]
</span><span>#![</span><span style="color:#bf616a;">const_eval_limit </span><span>= &quot;</span><span style="color:#a3be8c;">0</span><span>&quot;]
</span><span style="color:#b48ead;">pub mod </span><span>ray;
</span><span style="color:#b48ead;">pub mod </span><span>util;
</span><span style="color:#b48ead;">pub mod </span><span>vec3;
</span><span>
</span><span style="color:#b48ead;">pub use </span><span>ray::*;
</span><span style="color:#b48ead;">pub use </span><span>vec3::*;
</span><span>
</span><span style="color:#b48ead;">pub type </span><span>Point3 = Vec3;
</span><span style="color:#b48ead;">pub type </span><span>Color = Vec3;
</span></code></pre>
<h4 id="const-eval-limit">const_eval_limit</h4>
<p><code>const_eval_limit</code>とは<code>const fn</code>の中でのステップ数の制限をコントロールするための<code>feature</code>です。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#bf616a;">feature</span><span>(const_eval_limit)]
</span><span>#![</span><span style="color:#bf616a;">const_eval_limit </span><span>= &quot;</span><span style="color:#a3be8c;">N</span><span>&quot;]
</span></code></pre>
<p>とすることでステップ数の制限を<code>N</code>に設定できます。N = 0のときは無制限になります。<br />
これを使用しないと<code>const fn</code>で<code>sqrt</code>を呼び出しただけでステップ数の上限に引っかかってしまいまともにコードを書けそうになかったので追加しました。</p>
<h3 id="main-rs">main.rs</h3>
<p><code>main.rs</code>の内容を先に貼っておきます。
変更点がない箇所は省略しています。</p>
<details><summary>main.rs</summary>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#bf616a;">feature</span><span>(const_trait_impl)]
</span><span>#![</span><span style="color:#bf616a;">feature</span><span>(const_fn_floating_point_arithmetic)]
</span><span>#![</span><span style="color:#bf616a;">feature</span><span>(const_mut_refs)]
</span><span>#![</span><span style="color:#bf616a;">feature</span><span>(const_eval_limit)]
</span><span>#![</span><span style="color:#bf616a;">const_eval_limit </span><span>= &quot;</span><span style="color:#a3be8c;">0</span><span>&quot;]
</span><span>
</span><span style="color:#b48ead;">use </span><span>image::ImageFormat;
</span><span style="color:#b48ead;">use </span><span>ray_tracing_in_one_weekend_compile_time::*;
</span><span>
</span><span style="color:#b48ead;">const </span><span style="color:#d08770;">ASPECT_RATIO</span><span>: </span><span style="color:#b48ead;">f64 </span><span>= </span><span style="color:#d08770;">16.0 </span><span>/ </span><span style="color:#d08770;">9.0</span><span>;
</span><span style="color:#b48ead;">const </span><span style="color:#d08770;">IMAGE_WIDTH</span><span>: </span><span style="color:#b48ead;">usize </span><span>= </span><span style="color:#d08770;">400</span><span>;
</span><span style="color:#b48ead;">const </span><span style="color:#d08770;">IMAGE_HEIGHT</span><span>: </span><span style="color:#b48ead;">usize </span><span>= (</span><span style="color:#d08770;">IMAGE_WIDTH </span><span>as </span><span style="color:#b48ead;">f64 </span><span>/ </span><span style="color:#d08770;">ASPECT_RATIO</span><span>) as </span><span style="color:#b48ead;">usize</span><span>;
</span><span style="color:#b48ead;">const </span><span style="color:#d08770;">PIXEL_COUNT</span><span>: </span><span style="color:#b48ead;">usize </span><span>= </span><span style="color:#d08770;">IMAGE_WIDTH </span><span>* </span><span style="color:#d08770;">IMAGE_HEIGHT</span><span>;
</span><span>
</span><span style="color:#b48ead;">const fn </span><span style="color:#8fa1b3;">ray_color</span><span>(</span><span style="color:#bf616a;">ray</span><span>: &amp;Ray) -&gt; Color {
</span><span>    </span><span style="color:#b48ead;">let</span><span> unit_direction = </span><span style="color:#96b5b4;">unit_vector</span><span>(&amp;ray.</span><span style="color:#96b5b4;">direction</span><span>());
</span><span>    </span><span style="color:#b48ead;">let</span><span> t = </span><span style="color:#d08770;">0.5 </span><span>* unit_direction.y + </span><span style="color:#d08770;">1.0</span><span>;
</span><span>    (</span><span style="color:#d08770;">1.0 </span><span>- t) * Color::new(</span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>) + t * Color::new(</span><span style="color:#d08770;">0.5</span><span>, </span><span style="color:#d08770;">0.7</span><span>, </span><span style="color:#d08770;">1.0</span><span>)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() -&gt; anyhow::Result&lt;()&gt; {
</span><span>    </span><span style="color:#65737e;">// 省略
</span><span>}
</span><span>
</span><span style="color:#b48ead;">const fn </span><span style="color:#8fa1b3;">ray_trace</span><span>() -&gt; [Color; </span><span style="color:#d08770;">PIXEL_COUNT</span><span>] {
</span><span>    </span><span style="color:#b48ead;">let</span><span> viewport_height = </span><span style="color:#d08770;">2.0</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> viewport_width = viewport_height * </span><span style="color:#d08770;">ASPECT_RATIO</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> focal_length = </span><span style="color:#d08770;">1.0</span><span>;
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> origin = Point3::</span><span style="color:#d08770;">ZERO</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> horizontal = Vec3::new(viewport_width, </span><span style="color:#d08770;">0.0</span><span>, </span><span style="color:#d08770;">0.0</span><span>);
</span><span>    </span><span style="color:#b48ead;">let</span><span> vertical = Vec3::new(</span><span style="color:#d08770;">0.0</span><span>, viewport_height, </span><span style="color:#d08770;">0.0</span><span>);
</span><span>    </span><span style="color:#b48ead;">let</span><span> lower_left_corner =
</span><span>        origin - horizontal / </span><span style="color:#d08770;">2.0 </span><span>- vertical / </span><span style="color:#d08770;">2.0 </span><span>- Vec3::new(</span><span style="color:#d08770;">0.0</span><span>, </span><span style="color:#d08770;">0.0</span><span>, focal_length);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> pixel_colors = [Color::</span><span style="color:#d08770;">ZERO</span><span>; </span><span style="color:#d08770;">PIXEL_COUNT</span><span>];
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> i = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> j = (</span><span style="color:#d08770;">IMAGE_HEIGHT </span><span>- </span><span style="color:#d08770;">1</span><span>) as </span><span style="color:#b48ead;">i32</span><span>;
</span><span>    </span><span style="color:#65737e;">// forが使えないのでwhileで代用
</span><span>    </span><span style="color:#b48ead;">while </span><span style="color:#d08770;">0 </span><span>&lt;= j {
</span><span>        </span><span style="color:#b48ead;">while</span><span> i &lt; </span><span style="color:#d08770;">IMAGE_WIDTH </span><span>{
</span><span>            </span><span style="color:#b48ead;">let</span><span> u = (i as </span><span style="color:#b48ead;">f64</span><span>) / (</span><span style="color:#d08770;">IMAGE_WIDTH </span><span>- </span><span style="color:#d08770;">1</span><span>) as </span><span style="color:#b48ead;">f64</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> v = (j as </span><span style="color:#b48ead;">f64</span><span>) / (</span><span style="color:#d08770;">IMAGE_HEIGHT </span><span>- </span><span style="color:#d08770;">1</span><span>) as </span><span style="color:#b48ead;">f64</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> r = Ray::new(
</span><span>                &amp;origin,
</span><span>                &amp;(lower_left_corner + u * horizontal + v * vertical - origin),
</span><span>            );
</span><span>            pixel_colors[j as </span><span style="color:#b48ead;">usize </span><span>* </span><span style="color:#d08770;">IMAGE_WIDTH </span><span>+ i] = </span><span style="color:#96b5b4;">ray_color</span><span>(&amp;r);
</span><span>            i += </span><span style="color:#d08770;">1</span><span>;
</span><span>        }
</span><span>        i = </span><span style="color:#d08770;">0</span><span>;
</span><span>        j -= </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>    pixel_colors
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 省略
</span></code></pre>
</details>
<p>まず<code>main.rs</code>でも<code>const_eval_limit</code>が追加されています。
ループの中でステップ数の上限に引っかかるので上限なしにしてあります。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#bf616a;">feature</span><span>(const_eval_limit)]
</span><span>#![</span><span style="color:#bf616a;">const_eval_limit </span><span>= &quot;</span><span style="color:#a3be8c;">0</span><span>&quot;]
</span></code></pre>
<p>画像は横400を基準としてアスペクト比16:9になるように設定しています。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">const </span><span style="color:#d08770;">ASPECT_RATIO</span><span>: </span><span style="color:#b48ead;">f64 </span><span>= </span><span style="color:#d08770;">16.0 </span><span>/ </span><span style="color:#d08770;">9.0</span><span>;
</span><span style="color:#b48ead;">const </span><span style="color:#d08770;">IMAGE_WIDTH</span><span>: </span><span style="color:#b48ead;">usize </span><span>= </span><span style="color:#d08770;">400</span><span>;
</span><span style="color:#b48ead;">const </span><span style="color:#d08770;">IMAGE_HEIGHT</span><span>: </span><span style="color:#b48ead;">usize </span><span>= (</span><span style="color:#d08770;">IMAGE_WIDTH </span><span>as </span><span style="color:#b48ead;">f64 </span><span>/ </span><span style="color:#d08770;">ASPECT_RATIO</span><span>) as </span><span style="color:#b48ead;">usize</span><span>;
</span></code></pre>
<p><code>ray_color</code>関数は引数の<code>Ray</code>を飛ばしてヒットした箇所の色を返す関数です。<br />
現時点ではヒットするオブジェクトがないのでレイの向きを元に返す色を決めています。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">const fn </span><span style="color:#8fa1b3;">ray_color</span><span>(</span><span style="color:#bf616a;">ray</span><span>: &amp;Ray) -&gt; Color {
</span><span>    </span><span style="color:#b48ead;">let</span><span> unit_direction = </span><span style="color:#96b5b4;">unit_vector</span><span>(&amp;ray.</span><span style="color:#96b5b4;">direction</span><span>());
</span><span>    </span><span style="color:#b48ead;">let</span><span> t = </span><span style="color:#d08770;">0.5 </span><span>* unit_direction.y + </span><span style="color:#d08770;">1.0</span><span>;
</span><span>    (</span><span style="color:#d08770;">1.0 </span><span>- t) * Color::new(</span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>) + t * Color::new(</span><span style="color:#d08770;">0.5</span><span>, </span><span style="color:#d08770;">0.7</span><span>, </span><span style="color:#d08770;">1.0</span><span>)
</span><span>}
</span></code></pre>
<p><code>ray_trace</code>関数ではピクセルごとにレイを生成して<code>ray_color</code>関数の返り値を配列に格納しています。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">const fn </span><span style="color:#8fa1b3;">ray_trace</span><span>() -&gt; [Color; </span><span style="color:#d08770;">PIXEL_COUNT</span><span>] {
</span><span>    </span><span style="color:#b48ead;">let</span><span> viewport_height = </span><span style="color:#d08770;">2.0</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> viewport_width = viewport_height * </span><span style="color:#d08770;">ASPECT_RATIO</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> focal_length = </span><span style="color:#d08770;">1.0</span><span>;
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> origin = Point3::</span><span style="color:#d08770;">ZERO</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> horizontal = Vec3::new(viewport_width, </span><span style="color:#d08770;">0.0</span><span>, </span><span style="color:#d08770;">0.0</span><span>);
</span><span>    </span><span style="color:#b48ead;">let</span><span> vertical = Vec3::new(</span><span style="color:#d08770;">0.0</span><span>, viewport_height, </span><span style="color:#d08770;">0.0</span><span>);
</span><span>    </span><span style="color:#b48ead;">let</span><span> lower_left_corner =
</span><span>        origin - horizontal / </span><span style="color:#d08770;">2.0 </span><span>- vertical / </span><span style="color:#d08770;">2.0 </span><span>- Vec3::new(</span><span style="color:#d08770;">0.0</span><span>, </span><span style="color:#d08770;">0.0</span><span>, focal_length);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> pixel_colors = [Color::</span><span style="color:#d08770;">ZERO</span><span>; </span><span style="color:#d08770;">PIXEL_COUNT</span><span>];
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> i = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> j = (</span><span style="color:#d08770;">IMAGE_HEIGHT </span><span>- </span><span style="color:#d08770;">1</span><span>) as </span><span style="color:#b48ead;">i32</span><span>;
</span><span>    </span><span style="color:#65737e;">// forが使えないのでwhileで代用
</span><span>    </span><span style="color:#b48ead;">while </span><span style="color:#d08770;">0 </span><span>&lt;= j {
</span><span>        </span><span style="color:#b48ead;">while</span><span> i &lt; </span><span style="color:#d08770;">IMAGE_WIDTH </span><span>{
</span><span>            </span><span style="color:#b48ead;">let</span><span> u = (i as </span><span style="color:#b48ead;">f64</span><span>) / (</span><span style="color:#d08770;">IMAGE_WIDTH </span><span>- </span><span style="color:#d08770;">1</span><span>) as </span><span style="color:#b48ead;">f64</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> v = (j as </span><span style="color:#b48ead;">f64</span><span>) / (</span><span style="color:#d08770;">IMAGE_HEIGHT </span><span>- </span><span style="color:#d08770;">1</span><span>) as </span><span style="color:#b48ead;">f64</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> r = Ray::new(
</span><span>                &amp;origin,
</span><span>                &amp;(lower_left_corner + u * horizontal + v * vertical - origin),
</span><span>            );
</span><span>            pixel_colors[j as </span><span style="color:#b48ead;">usize </span><span>* </span><span style="color:#d08770;">IMAGE_WIDTH </span><span>+ i] = </span><span style="color:#96b5b4;">ray_color</span><span>(&amp;r);
</span><span>            i += </span><span style="color:#d08770;">1</span><span>;
</span><span>        }
</span><span>        i = </span><span style="color:#d08770;">0</span><span>;
</span><span>        j -= </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>    pixel_colors
</span><span>}
</span></code></pre>
<h2 id="matome">まとめ</h2>
<p>今回でようやく<code>Ray</code>が登場しました。<br />
かんたんに書くためにまた新しい<code>const_eval_limit</code>という<code>feature</code>を使用しました。
どんどんnightlyでしか書けないコードになってきましたね。stableの制限の中でもやりたいと思ったことはあるのですがだいぶ難しそうです。<br />
次は球とレイの交差判定を行います。</p>
</p>
<hr>
<p class="share_buttons">
  <a class="twitter-share-button" data-text="Rustでコンパイル時レイトレーシング3 | blockの巣" href="https://twitter.com/intent/tweet">Tweet</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
</p>

    </div>
  </section>
  <footer>
    
    
    copyright 2019 block.
    
    
  </footer>

  
  <script>
    const ga_tracking_id = "UA-148823095-1";
    const ga_accept_message = `サイトを見てもらえていることがわかるとテンション上がるので同意してほしいです。
当サイトではアクセス解析ツール「Google Analytics」を使用しています。このGoogleアナリティクスはトラフィックデータの収集のためにCookieを使用します。`;
    const privacy_policy_url = "https://block-cube-lib.github.io/privacy-policy/";
  </script>
  <script src="https://block-cube-lib.github.io/js/ga-cookie-accept.js"></script>
  
</body>

</html>
